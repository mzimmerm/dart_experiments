// See https://stackoverflow.com/questions/53886304/understanding-factory-constructor-code-example-dart
// See https://dart.dev/guides/language/language-tour#factory-constructors

// Terminology: 
//   - Constructor is either FACTORY or NON-FACTORY. NON-FACTORY equivalent name is GENERATIVE.
//   - Both  FACTORY and NON-FACTORY can be both
//     - UNNAMED [MyClass()] or [factory MyClass()].
//     - NAMED [MyClass.someName()], [MyClass._someName()], [factory MyClass.someName()], [factory MyClass._someName()]
//   - Lemma: UNNAMED constructor is always PUBLIC, as the name is 'MyClass(args)' - no _
//   - Class MAY in principle, have 4 types of constructors:
//      FACTORY NAMED (0+), FACTORY UNNAMED (0, 1), GENERATIVE NAMED (0+), GENERATIVE UNNAMED (0, 1).
//      - Some combinations are prohibited, and some required, see rules below.
//
// Obvious facts:
//
//   - If a class has an UNNAMED constructor [MyClass() (explicit or generated) or factory MyClass()]
//     then the class is public.
//     (Public in a sense that code outside of the library can
//     access an instance of the class, either through creating instance, or
//     returning a self-instance or subclass instance from the factory)
//   - There can NOT be 2+ UNNAMED constructor [e.g. MyClass(args) and MyClass()]
//     or [MyClass() and factory MyClass()] is logical, because in Dart constructors are just methods,
//     and method names must be unique - overloaded methods [e.g. MyClass(args) and MyClass()]
//     are not allowed in Dart.
//
// Rules:
//
//   Rule 1. *class MUST have "1+" GENERATIVE constructors* [names such as: MyClass() or MyClass.someName() or MyClass._someName()]
//
//            Note: The existence of a generative constructor is needed for code to
//                   be able to create instances of the class!!
//
//            Note: If conditions in Rule 3 apply, the required "1" GENERATIVE constructor [MyClass()]
//                   is generated by Dart, so we can rephrase this rule
//                   Class CODE      may have "0"      GENERATIVE constructors under some circumstances
//                   (circumstances are, that the constructor name [MyClass] is not "stolen"
//                    by the presence of factory constructor [factory MyClass()]..
//
//     - Notes about GENERATIVE constructors
//       - can be NAMED OR UNNAMED (UNNAMED is always public)
//       - The NAMED constructors can be library PRIVATE (start with _) or PUBLIC.
//         If all generative constructors are PRIVATE,
//         class instances can be created but class cannot be extended in another library,
//         because valid extensions must be able to generate a super instance.
//       - If the UNNAMED FACTORY [factory MyClass()] exists, this GENERATIVE constructor
//         must be NAMED [e.g. MyClass.someName() or MyClass._someName()] to satisfy Rule 2.
//       - If the UNNAMED GENERATIVE [MyClass()] is used or generated, it's existence satisfies Rule 2.
//
//   Rule 2. *PUBLIC class      MUST have: "1"      UNNAMED constructor   [MyClass(args)] or [factory MyClass(args)]*
//            PUBLIC class CODE MUST have: "0 OR 1" UNNAMED constructors.
//
//       - This UNNAMED constructor can be either FACTORY  [factory MyClass(args)]
//         or GENERATIVE MyClass(args)]
//
//       Note: If a class CODE has "0" UNNAMED constructors [0 MyClass(), 0 factory MyClass()],
//             then the UNNAMED GENERATIVE constructor [MyClass()] is generated IFF condition
//             in Rule 3 applies. If Rule 3 conditions do not apply, error.
//
//      Lemma 1.1 (compilation error condition):
//               If class CODE has "1" FACTORY UNNAMED constructor [factory MyClass],
//               and "0" GENERATIVE constructors, this is a compilation ERROR.
//               Reason: The generative no-arg [MyClass()] cannot be generated,
//                       because the name [MyClass] is already taken by the factory.
//                       Class with no GENERATIVE constructor cannot be instantiated.
//                       It could be extended, but the extensions have no
//                       way to be created all the way up to MyClass,
//                       and because the factory must return self
//                       or extension (none of which can be created), this is COMPILE ERROR.
//
//   Rule 3. Condition when Dart *generates* the default UNNAMED GENERATIVE no-arg constructor [MyClass()]
//
//      Dart generates the [MyClass()] constructor for the class, if and only if (IFF):
//      a) class CODE has "0" UNNAMED FACTORY       [0 factory MyClass(args)] in CODE
//      -   OR (inclusive or)
//      b) class CODE as "0" NAMED GENERATIVE (0 [MyClass.someName] or [MyClass._someName]) (public or private)
//
//      Lemma 3.1 (recipe to create a private NON-FACTORY class in Dart):
//             If class CODE has only PRIVATE GENERATIVE constructors ("1+" of them)
//             [MyClass._someName1[, [MyClass._someName2] etc,
//             AND "0" FACTORY constructors,
//             Then the class is PRIVATE.
//               (in the sense no other library code can create it's instance,
//               although such instance can be passed to it as parameter by importing the class's library)
//             Reason: There is no way to publicly construct instance (construct in code of another library),
//                     - because the default no-arg [MyClass()] is not generated, and the
//                       PRIVATE GENERATIVE constructors cannot be invoked in code in another library.
//
//             Note: This Lemma describes a situation where
//                   Rule 3b true via existence of only private generative constructor, Rule 3a true.
//
//      Lemma 3.2 If a class CODE has 1 UNNAMED FACTORY constructor [factory MyClass()] (this makes [MyClass()] impossible),
//             for an instance to be created, it MUST have "1+" NAMED GENERATIVE constructors
//              [MyClass.from(args) or MyClass._from(args)], because something has to exist to create the instance.
//             Note: This Lemma describes a situation where
//                   Rule 3a is false, Rule 3b is true
//
//      Lemma 3.2.1 (recipe to create a PUBLIC NON-SINGLETON FACTORY class)
//             Under conditions of Lemma 1.2., if "1+" NAMED GENERATIVE constructor is PUBLIC
//             [MyClass.from(args)], the resulting class is a NON-SINGLETON FACTORY.
//             Note: This Lemma describes a situation where
//                   Rule 3a is false, Rule 3b is true via a PUBLIC GENERATIVE [MyClass.from(args)]
//
//      Lemma 3.2.2 (recipe to create a PUBLIC SINGLETON FACTORY class)
//             Under conditions of Lemma 3.2., if ALL NAMED GENERATIVE constructor are PRIVATE
//             [say only one, MyClass._internal()]
//             the resulting class CAN BE MADE to a SINGLETON FACTORY by returning a static SINGLE instance from
//             the FACTORY [factory MyClass() { return _instance; }], assuming [static final _instance = MyClass._internal();]
//             Note: This Lemma describes a situation where
//                   Rule 3a is false, Rule 3b is true via a PRIVATE GENERATIVE [MyClass._internal()]
//             Note: There is no way for any code outside our library to create another instance,
//                    as the GENERATIVE [MyClass._internal()] can only be called from the library the singleton
//                    is defined.
//                    Obviously it's library can still crew up and create another instance, but that is a developer error.
//
//
//   Rule 4. Class has "0+" NAMED constructors
//
//     Examples: MyClass.someName(),  factory MyClass.someFactory(),
//               MyClass._someName(), factory MyClass._someFactory()
//
//   4. If a class has 0 GENERATIVE constructors (perhaps ONLY FACTORY constructors),
//      and 0 NAMED FACTORY constructors [no factory MyClass.someName(args)],
//      then a default GENERATIVE PUBLIC constructor MyClass() is generated.
//      Note: The condition 0 NAMED FACTORY is needed, as the generated MyClass name would
//             clash with the named factory.
//      Note: The condition can be rephrased as:
//             If a class has no constructors at all,
//             OR only UNNAMED FACTORY constructor [factory MyClass(args)],
//             then a default GENERATIVE PUBLIC constructor [MyClass()] is generated.
//      Lemma: If a class has 1 or more private GENERATIVE constructors and 0 public GENERATIVE constructors,
//             it cannot be extended in another library,
//             [because the extension constructor MUST call a GENERATIVE super(args)].
//             Note: The private GENERATIVE must be NAMED, like MyClass._internal,
//                   because UNNAMED constructor is always PUBLIC.
//      Lemma: If a class has only FACTORY constructors, (one or more GENERATIVE must be still provided),
//             it cannot be extended iff all GENERATIVE are private.
//             (in a nutshell, class with FACTORY constructors cannot be extended,
//             unless GENERATIVE PUBLIC is provided)

class LoggerOneUnnamedFactory {
  // Instance members
  String? name;
  bool mute = false;

  // _cache is library-private static property (class property)
  static final Map<String, LoggerOneUnnamedFactory?> _cache = <String, LoggerOneUnnamedFactory?>{};

  // The (single UNNAMED) constructor (FACTORY)
  // This is the PRIMARY FACTORY
  factory LoggerOneUnnamedFactory(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name]!;
    } else {
      // Calling NAMED GENERATIVE constructor
      final logger = LoggerOneUnnamedFactory.internal(name); // null -> Runtime Error
      _cache[name] = logger;
      return logger;
    }
    // Shorter alternative : return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  // Another (must be NAMED) FACTORY constructor, forwards to UNNAMED FACTORY above
  factory LoggerOneUnnamedFactory.fromJson(Map<String, String> json) {
    return LoggerOneUnnamedFactory(json['name'].toString());
  }

  // Library-private GENERATIVE NAMED constructor.
  // Needed - there must be a constructor that actually generates instance
  // If commented out, there is NO WAY to create non-null instance, and
  //   Runtime Error ensues when calling the factory constructor,
  //   but it is NOT a compile error (we made various nullable hacks to achieve that.
  LoggerOneUnnamedFactory.internal(this.name);

  // Error: UNNAMED is already defined: Logger() : name = 'initial';
  
  void log(String msg) {
    if (!mute) print(msg);
  }
  
  @override
  String toString() {
    return 'Logger name=$name, muted=$mute';
  }

  /// Example of deprecated method
  @Deprecated('[loggerMethod] is deprecated, since there is a better way.')
  void loggerMethod() {
    // throw StateError('This is deprecated.');
  }

}

class PointOneUnnamedGenerative {
  // Instance members
  final double x;

  // The (single UNNAMED) constructor (GENERATIVE)
  // This is the PRIMARY GENERATIVE
  PointOneUnnamedGenerative(this.x);
  // same as : PointOneUnnamedGenerative(double x) : this.x = x {}

  // Another (must be NAMED) GENERATIVE constructor, forwards to UNNAMED above
  PointOneUnnamedGenerative.fromJson(Map<String, String> json) :
    this(double.tryParse(json['x']!)!);

  // PointOneUnnamedGenerative() : x = 0.0; // Error: The unnamed constructor (PointOneUnnamedGenerative) is already defined:

  @override
  String toString() {
    return 'Point p: x=$x';
  }
}

// conclusion: To make a Dart class non-extensible, define all GENERATIVE constructors PRIVATE.
// note:       Such GENERATIVE may be NAMED or UNNAMED. The reason for non-extensibility is,
//             if we define (in code) a GENERATIVE constructor, Dart no longer
//             generates the default no-argument constructor
//             (which WOULD be PUBLIC as it's name would be same as class name , without _ ).
class PointNonExtensibleOneUnnamedGenerative {
  // Instance members
  final double? x;

  // The (NAMED) constructor (GENERATIVE)
  // This is the PRIMARY GENERATIVE
  // IMPORTANT NOTE: IF WE DEFINE *ANY* GENERATIVE constructor (NAMED or UNNAMED),
  //                 (as we do here with _internal(this.x))
  //                 then Dart does NOT generate the default no-arg
  //                 NAMED PointNonExtensibleOneUnnamedGenerative,
  //                 so if the GENERATIVE is PRIVATE
  //                 (as it is here _internal(this.x)),
  //                 then such class in NON EXTENSIBLE
  PointNonExtensibleOneUnnamedGenerative._internal(this.x);
  // same as : PointNonExtensibleOneUnnamedGenerative._(double x) : this.x = x {}

  // NO PUBLIC CONSTRUCTOR may exist if we want to make this non-extensible
  // PointNonExtensibleOneUnnamedGenerative.fromJson(Map<String, String> json) :
  //       this._(double.tryParse(json['x']!)!);

  @override
  String toString() {
    return 'Point nep: x=$x';
  }
}

main() {

  // Logger

  var l1 = LoggerOneUnnamedFactory('one');
  var l2 = LoggerOneUnnamedFactory('one');
  assert(identical(l1, l2)); // Uses ==
  assert(l1 == l2); // Uses ==
  var l3 = LoggerOneUnnamedFactory('two');
  assert(!identical(l1, l3));
  assert(l1 != l3);

  // var l4 = LoggerOneUnnamedFactory(); // Not generated, as GENERATIVE LoggerOneUnnamedFactory(NAME) exists
  
  l1.log('from l1');
  l2.log('from l2');
  l3.log('from l3');

  print('');

  // Point
  var p1 = PointOneUnnamedGenerative(0.0);
  var p2 = PointOneUnnamedGenerative(1.0);

  print(p1);
  print(p2);

  print('');

  // Non extensible point

  // We can create instance using '_' in the same library, but not outside of it.
  // So no extensions of PointNonExtensibleOneUnnamedGenerative can exist!
  var nep1 = PointNonExtensibleOneUnnamedGenerative._internal(2.0);
  var nep2 = PointNonExtensibleOneUnnamedGenerative._internal(3.0);
  // var nep3 = PointNonExtensibleOneUnnamedGenerative(); // This does not exist - is NOT generated!!

  print(nep1);
  print(nep2);

}