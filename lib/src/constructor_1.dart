// See https://stackoverflow.com/questions/53886304/understanding-factory-constructor-code-example-dart
// See https://dart.dev/guides/language/language-tour#factory-constructors

// Terminology: 
//   - Constructor is either FACTORY or NON-FACTORY. NON-FACTORY equivalent name is GENERATIVE.
//   - Both  FACTORY and NON-FACTORY can be both
//     - UNNAMED [MyClass()] or [factory MyClass()].
//     - NAMED [MyClass.someName()], [MyClass._someName()], [factory MyClass.someName()], [factory MyClass._someName()]
//   - Lemma: UNNAMED constructor is always PUBLIC, as the name is 'MyClass(args)' - no _
//   - Class MAY in principle, have 4 types of constructors:
//      FACTORY NAMED (0+), FACTORY UNNAMED (0, 1), GENERATIVE NAMED (0+), GENERATIVE UNNAMED (0, 1).
//      - Some combinations are prohibited, and some required, see rules below.
//
// Obvious facts:
//
//   - If a class has an UNNAMED constructor [MyClass() (explicit or generated) or factory MyClass()]
//     then the class is public.
//     (Public in a sense that code outside of the library can
//     access an instance of the class, either through creating instance, or
//     returning a self-instance or subclass instance from the factory)
//   - There can NOT be 2+ UNNAMED constructor [e.g. MyClass(args) and MyClass()]
//     or [MyClass() and factory MyClass()] is logical, because in Dart constructors are just methods,
//     and method names must be unique - overloaded methods [e.g. MyClass(args) and MyClass()]
//     are not allowed in Dart.
//
// Rules:
//
//   Rule 1. *class MUST have "1+" GENERATIVE constructors* [names such as: MyClass() or MyClass.someName() or MyClass._someName()]
//
//            Note: The existence of a generative constructor is needed for code to
//                   be able to create instances of the class!!
//
//            Note: If conditions in Rule 3 apply, the required "1" GENERATIVE constructor [MyClass()]
//                   is generated by Dart, so we can rephrase this rule
//                   Class CODE      may have "0"      GENERATIVE constructors under some circumstances
//                   (circumstances are, that the constructor name [MyClass] is not "stolen"
//                    by the presence of factory constructor [factory MyClass()]..
//
//     - Notes about GENERATIVE constructors
//       - can be NAMED OR UNNAMED (UNNAMED is always public)
//       - The NAMED constructors can be library PRIVATE (start with _) or PUBLIC.
//         If all generative constructors are PRIVATE,
//         class instances can be created but class cannot be extended in another library,
//         because valid extensions must be able to generate a super instance.
//       - If the UNNAMED FACTORY [factory MyClass()] exists, this GENERATIVE constructor
//         must be NAMED [e.g. MyClass.someName() or MyClass._someName()] to satisfy Rule 2.
//       - If the UNNAMED GENERATIVE [MyClass()] is used or generated, it's existence satisfies Rule 2.
//
//   Rule 2. *PUBLIC class      MUST have: "1"      UNNAMED constructor   [MyClass(args)] or [factory MyClass(args)]; the UNNAMED generative may be Dart-added, unless it is prevented by Rule 3 not applying*
//            PUBLIC class CODE MUST have: "0 OR 1" UNNAMED constructors.
//
//       - This UNNAMED constructor can be either FACTORY  [factory MyClass(args)]
//         or GENERATIVE MyClass(args)]
//
//       Note: If a class CODE has "0" UNNAMED constructors [0 MyClass(), 0 factory MyClass()],
//             then the UNNAMED GENERATIVE constructor [MyClass()] is generated IFF condition
//             in Rule 3 applies. If Rule 3 conditions do not apply, error.
//
//      Lemma 1.1 (compilation error condition):
//               If class CODE has "1" FACTORY UNNAMED constructor [factory MyClass],
//               and "0" GENERATIVE constructors, this is a compilation ERROR.
//               Reason: The generative no-arg [MyClass()] cannot be generated,
//                       because the name [MyClass] is already taken by the factory.
//                       Class with no GENERATIVE constructor cannot be instantiated.
//                       It could be extended, but the extensions have no
//                       way to be created all the way up to MyClass,
//                       and because the factory must return self
//                       or extension (none of which can be created), this is COMPILE ERROR.
//
//   Rule 3. Condition when Dart *generates* the default UNNAMED GENERATIVE no-arg constructor [MyClass()] (public by definition)
//
//      Dart generates the [MyClass()] constructor for the class, if and only if (IFF):
//      a) class CODE has "0" UNNAMED FACTORY       [0 factory MyClass(args)]
//      - AND
//      b) class CODE as "0" NAMED GENERATIVE (0 [MyClass.someName] or [MyClass._someName]) (public or private)
//
//      Note: If either a) or b) are FALSE, then the default constructor is NOT generated
//
//      Lemma 3.1: Recipe for creating a PRIVATE NON-FACTORY class in Dart:
//
//             If we provide in the class CODE:
//             - Only PRIVATE GENERATIVE constructors ("1+" of them)
//               [MyClass._someName1[, [MyClass._someName2] etc,
//             - "0" public FACTORY constructors
//             then the class is PRIVATE (in the sense other library code
//             CAN NOT create it's instance, although such instance can be passed
//             to it as parameter by importing the class's library)
//
//             Note: private generative constructor must be named. Unnamed is always public.
//
//             Reason: There is no way to publicly construct instance (construct in code of another library),
//                     - because the default no-arg [MyClass()] is not generated, and the
//                       PRIVATE GENERATIVE constructors cannot be invoked in code in another library.
//
//             Note: This Lemma describes a situation where
//                   Rule 3a is true,
//                   Rule 3b is false (via existence of 1+ private generative constructor).
//
//      Lemma 3.2: If we provide in the class CODE
//                - "1" UNNAMED FACTORY constructor [factory MyClass()]
//                then, for an instance to be created, we MUST also provide "1+"
//                NAMED GENERATIVE constructors [MyClass.from(args) or MyClass._from(args)],
//                because something has to exist to create the instance.
//
//                Note: This Lemma describes a situation where
//                      Rule 3a is false via existence of "1" UNNAMED FACTORY
//                      Rule 3b is FORCED to be false!
//                              via forcing [MyClass.from(args) or MyClass._from(args)],
//                              otherwise error
//
//      Lemma 3.2.1: Recipe for creating a PUBLIC FACTORY NON-SINGLETON class:
//
//             If we provide in CODE
//             - "1+" public NAMED GENERATIVE constructors [MyClass.from(args)],
//             - "0+" NAMED FACTORY
//             - "1+ UNNAMED FACTORY [factory MyClass], then resulting class is a NON-SINGLETON FACTORY.
//
//             Reason:
//             Note: This Lemma describes a situation where
//                   Rule 3a is false via a public NAMED GENERATIVE [MyClass.from(args)]),
//                   Rule 3b is true
//
//      Lemma 3.2.2: Recipe to create a PUBLIC FACTORY SINGLETON class:
//             If
//             - ALL NAMED GENERATIVE constructor are PRIVATE [say only one, MyClass._internal()]
//             - then the resulting class CAN BE MADE to a SINGLETON FACTORY by providing
//               a UNNAMED FACTORY [factory MyClass() { return _instance; }], returning a static SINGLE instance
//               assuming [static final _instance = MyClass._internal();]
//
//             Reason: There is no way for any code outside our library to create another instance,
//                    as the GENERATIVE [MyClass._internal()] can only be called from the library the singleton
//                    is defined.
//                    Obviously our library can still screw up and create another instance,
//                    but that would be a developer error.
//             Note: This Lemma describes a situation where
//                   Rule 3a is false via "1" UNNAMED FACTORY [factory MyClass()]
//                   Rule 3b is false via a PRIVATE GENERATIVE [MyClass._internal()]
//
//   Rule 4. Class CODE has "0+" NAMED constructors
//
//     Examples: MyClass.someName(),  factory MyClass.someFactory(),
//               MyClass._someName(), factory MyClass._someFactory()
//
//      Lemma 4.1 : Recipe for making a class PRIVATE (no public use or public extensibility)
//
//             - Provide in code, a PRIVATE GENERATIVE constructor.
//             - Provide "0" UNNAMED FACTORY
//
//          Reason: In this situation, a default [MyClass()] constructor will NOT
//                  be generated. Such class cannot be used (created or extended) in another library (public),
//                  [because the extension constructor MUST call a GENERATIVE super(args)].
//             Note: The private GENERATIVE must be NAMED, like MyClass._internal,
//                   because UNNAMED constructor is always PUBLIC.

//      Lemma 4.2 : Recipe for making a class PUBLIC BUT NON-EXTENSIBLE PUBLICLY (public use, NO public extensibility - essentially 'final')
//
//             - Provide in code, a PRIVATE GENERATIVE constructor.
//             - Provide "1" UNNAMED FACTORY [factory MyClass()]
//
//

class LoggerOneUnnamedFactory {
  // Instance members
  String? name;
  bool mute = false;

  // _cache is library-private static property (class property)
  static final Map<String, LoggerOneUnnamedFactory?> _cache = <String, LoggerOneUnnamedFactory?>{};

  // The (single UNNAMED) constructor (FACTORY)
  // This is the PRIMARY FACTORY
  factory LoggerOneUnnamedFactory(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name]!;
    } else {
      // Calling NAMED GENERATIVE constructor
      final logger = LoggerOneUnnamedFactory.internal(name); // null -> Runtime Error
      _cache[name] = logger;
      return logger;
    }
    // Shorter alternative : return _cache.putIfAbsent(name, () => Logger._internal(name));
  }

  // Another (must be NAMED) FACTORY constructor, forwards to UNNAMED FACTORY above
  factory LoggerOneUnnamedFactory.fromJson(Map<String, String> json) {
    return LoggerOneUnnamedFactory(json['name'].toString());
  }

  // Library-private GENERATIVE NAMED constructor.
  // Needed - there must be a constructor that actually generates instance
  // If commented out, there is NO WAY to create non-null instance, and
  //   Runtime Error ensues when calling the factory constructor,
  //   but it is NOT a compile error (we made various nullable hacks to achieve that.
  LoggerOneUnnamedFactory.internal(this.name);

  // Error: UNNAMED is already defined: Logger() : name = 'initial';
  
  void log(String msg) {
    if (!mute) print(msg);
  }
  
  @override
  String toString() {
    return 'Logger name=$name, muted=$mute';
  }

  /// Example of deprecated method
  @Deprecated('[loggerMethod] is deprecated, since there is a better way.')
  void loggerMethod() {
    // throw StateError('This is deprecated.');
  }

}

class PointOneUnnamedGenerative {
  // Instance members
  final double x;

  // The (single UNNAMED) constructor (GENERATIVE)
  // This is the PRIMARY GENERATIVE
  PointOneUnnamedGenerative(this.x);
  // same as : PointOneUnnamedGenerative(double x) : this.x = x {}

  // Another (must be NAMED) GENERATIVE constructor, forwards to UNNAMED above
  PointOneUnnamedGenerative.fromJson(Map<String, String> json) :
    this(double.tryParse(json['x']!)!);

  // PointOneUnnamedGenerative() : x = 0.0; // Error: The unnamed constructor (PointOneUnnamedGenerative) is already defined:

  @override
  String toString() {
    return 'Point p: x=$x';
  }
}

// conclusion: To make a Dart class non-extensible, define all GENERATIVE constructors PRIVATE.
// note:       Such GENERATIVE may be NAMED or UNNAMED. The reason for non-extensibility is,
//             if we define (in code) a GENERATIVE constructor, Dart no longer
//             generates the default no-argument constructor
//             (which WOULD be PUBLIC as it's name would be same as class name , without _ ).
class PointNonExtensibleOneUnnamedGenerative {
  // Instance members
  final double? x;

  // The (NAMED) constructor (GENERATIVE)
  // This is the PRIMARY GENERATIVE
  // IMPORTANT NOTE: IF WE DEFINE *ANY* GENERATIVE constructor (NAMED or UNNAMED),
  //                 (as we do here with _internal(this.x))
  //                 then Dart does NOT generate the default no-arg
  //                 NAMED PointNonExtensibleOneUnnamedGenerative,
  //                 so if the GENERATIVE is PRIVATE
  //                 (as it is here _internal(this.x)),
  //                 then such class in NON EXTENSIBLE
  PointNonExtensibleOneUnnamedGenerative._internal(this.x);
  // same as : PointNonExtensibleOneUnnamedGenerative._(double x) : this.x = x {}

  // NO PUBLIC CONSTRUCTOR may exist if we want to make this non-extensible
  // PointNonExtensibleOneUnnamedGenerative.fromJson(Map<String, String> json) :
  //       this._(double.tryParse(json['x']!)!);

  @override
  String toString() {
    return 'Point nep: x=$x';
  }
}

/// This is how to create an equivalent of 'final' in Java
class NonExtendable {
  NonExtendable._singleGenerativeConstructor();

  // NonExtendable();

  factory NonExtendable() {
    return NonExtendable._singleGenerativeConstructor();
  }

  @override
  String toString(){
    return '$runtimeType is like final';
  }
}

/// Trying to extend it, something like this, will work in the
/// same library (same 'source file') but not in another library,
/// making the class [NonExtendable] same as 'final' in Java
/// from the perspective of any client code.
class ExtendsNonExtendableInSameLibrary extends NonExtendable {
  ExtendsNonExtendableInSameLibrary._singleGenerativeConstructor() : super._singleGenerativeConstructor();
  factory ExtendsNonExtendableInSameLibrary() {
    return ExtendsNonExtendableInSameLibrary._singleGenerativeConstructor();
  }
}

class DoesNotGenerateNoArgDefault {

  // Presence of UNNAMED FACTORY prevents Dart-code-generation of default constructor
  factory DoesNotGenerateNoArgDefault() {
    // return DoesNotGenerateNoArgDefault._singleGenerativeConstructor();
    // THIS RETURNED IS NOT THE NO-ARG GENERATIVE.
    // IT IS CALLING FACTORY, RESULTING IN STACK OVERFLOW
    return DoesNotGenerateNoArgDefault();
  }

  @override
  String toString(){
    return '$runtimeType is like final';
  }
}

class DoesNotGenerateNoArgDefaultEither {

  // Presence of ANY NAMED GENERATIVE prevents Dart-code-generation of default constructor
  DoesNotGenerateNoArgDefaultEither.any();

  void tryUseDefaultConstructor() {
    // Compile error: - default constructor was not generated:
    // DoesNotGenerateNoArgDefaultEither();
  }

  @override
  String toString(){
    return '$runtimeType is like final';
  }
}
main() {

  // Logger

  var l1 = LoggerOneUnnamedFactory('one');
  var l2 = LoggerOneUnnamedFactory('one');
  assert(identical(l1, l2)); // Uses ==
  assert(l1 == l2); // Uses ==
  var l3 = LoggerOneUnnamedFactory('two');
  assert(!identical(l1, l3));
  assert(l1 != l3);

  // var l4 = LoggerOneUnnamedFactory(); // Not generated, as GENERATIVE LoggerOneUnnamedFactory(NAME) exists
  
  l1.log('from l1');
  l2.log('from l2');
  l3.log('from l3');

  print('');

  // Point
  var p1 = PointOneUnnamedGenerative(0.0);
  var p2 = PointOneUnnamedGenerative(1.0);

  print(p1);
  print(p2);

  print('');

  // Non extensible point

  // We can create instance using '_' in the same library, but not outside of it.
  // So no extensions of PointNonExtensibleOneUnnamedGenerative can exist!
  var nep1 = PointNonExtensibleOneUnnamedGenerative._internal(2.0);
  var nep2 = PointNonExtensibleOneUnnamedGenerative._internal(3.0);
  // var nep3 = PointNonExtensibleOneUnnamedGenerative(); // This does not exist - is NOT generated!!

  print(nep1);
  print(nep2);

  // Create an instance of NonExtendable
  print ('${NonExtendable()}');

  // STACK OVERFLOW
  print ('${DoesNotGenerateNoArgDefault()}');

}